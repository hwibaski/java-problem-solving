# Bucket Sort - 버킷 정렬

버킷 정렬은 배열의 원소를 여러 버킷으로 분산하여 작동하는 정렬 알고리즘입니다. 각 버킷은 다른 정렬 알고리즘을 사용하거나 버킷 정렬을 반복 적용해 각각 정렬합니다

다른 정렬 알고리즘만큼 대중적이거나 널리 사용되지는 않습니다. 버킷 정렬은 정렬할 데이터 집합에 특정 범위 내의 값이 있을 때 잘 작동합니다.

## 개념

우리는 크기가 6인 배열을 정렬하려고 합니다. 이 배열의 각 요소들은 0 ~ 2의 값을 가지고 있습니다.

버킷 정렬의 핵심 아이디어는 정렬할 요소들과 그 갯수를 카운팅하는 하나의 map을 가지고 있는 것입니다.

[0, 2, 1, 0, 1, 1] 이 배열을 정렬하기 위해서는 아래와 같은 새로운 통계가(버킷) 필요합니다.

```text
0 : 2개
1 : 3개
2 : 1개
```

새로 만들어진 버킷을 기반으로 우리는 정렬된 배열을 얻어낼 수 있습니다.

```
public static int[] bucketSort(int[] arr) {
    // Assuming arr only contains 0, 1 or 2
    // arr이 0, 1, 2로 이루어져 있을 것이라고 가정합니다.
    int[] counts = {0, 0, 0};

    // arr의 요소들의 갯수를 counts 배열에 매핑합니다.
    for (int num: arr) {
        counts[num] += 1;
    }

    // counts(버킷) 배열을 이용해 원본 배열을 덮어씁니다.
    int i = 0;
    for (int n = 0; n < counts.length; n++) {
        for (int j = 0; j < counts[n]; j++) {
            arr[i] = n;
            i++;
        }
    }
    return arr;
}
```

> 주의 : 우리는 버킷을 만들기 위해서 원본 배열의 요소들의 범위를 알고 있어야 합니다.


출처 : https://neetcode.io/courses/dsa-for-beginners/13

## 시간 복잡도

버킷 정렬의 코드를 보고 아마 시간 복잡도가 O(n^2) 이라고 생각하실지도 모르겠습니다.

왜냐하면 원본 배열을 덮어쓰는 과정에서 이중 for문이 쓰이고 있기 때문이죠.

하지만 모든 이중 for문이 O(n^2)의 시간 복잡도를 가지는 것은 아닙니다.

버킷 정렬의 원본 배열을 덮어쓰는 코드는 O(n)의 시간 복잡도를 가집니다.

원본 배열이 [2, 1, 2, 0, 0, 2] 라고 가정했을 때 이중 포문은 실제로 n 만큼만 동작합니다.

```text
(n, i, j)
(0, 0, 0)
(0, 1, 1)
(1, 2, 0)
(2, 3, 0)
(2, 4, 1)
(2, 5, 2)
```

## stability

버킷 정렬은 안정성은 불안정합니다. 버킷 정렬은 애초에 원본 배열의 값들을 스왑해서 정렬하지 않기 때문입니다.

### reference

- https://neetcode.io/courses/dsa-for-beginners/13
