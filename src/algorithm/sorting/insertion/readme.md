# Insertion Sort - 삽입 정렬

삽입 정렬(insertion sort)은 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘입니다.

![Screen-Recording-2023-06-23-at-9 49 27-AM](https://github.com/hwibaski/java-problem-solving/assets/85930725/219e59b1-bdfe-4b19-abf7-8005308feb9f)

출처 : https://visualgo.net/en/sorting

## 개념

우리가 정렬하려는 배열의 크기는 5이고 [2,3,4,1,6] 이렇게 생겼습니다. 우리의 목표는 이 배열을 [1,2,3,4,6]과 같이 만드는 것입니다.

삽입 정렬은 배열을 서브 배열로 나누고 개별적으로 정렬하여 전체적으로 정렬된 배열을 생성한다고 말합니다.

크기가 1인 배열이 있다면([2,3,4,1,6]의 서브배열 [2]) 이 배열은 비교할 다른 요소가 없기 때문이 이미 정렬된 것으로 보아도 됩니다.

따라서 배열의 첫 번째 요소는 비교할 서브 배열이 없기 때문에 이미 정렬되어 있다고 가정합니다. (for loop의 시작 인덱스를 0번째 요소를 하지 않는다는 뜻)

다음 서브 배열은 [2,3] 입니다. 정렬을 하기 위해서는 서브배열의 요소들의 크기를 비교해야합니다. 크기가 2인 배열에서 이건 쉬운 일입니다.

그러나 더 큰 크기의 배열을 비교해기 위해서는 2개의 포인터가 필요합니다. i, j 를 투 포인터로 삼겠습니다.

```java
public static int[]insertionSort(int[] arr){
    // i가 1부터 시작
    for(int i = 1; i < arr.length; i++){
        // j 포인터는 i 보다 하나 앞의 요소를 가리킨다.
        int j=i - 1;

        // while 문 안에서 j--를 하기 때문에 arr[-1] 이 되는 상황을 방지하기 위한 조건
        // arr[j + 1] 은 i와 같다. 
        // 현재 요소와 바로 직전의 요소를 비교하고 swap 한다. 
        while(j > = 0 && arr[j + 1] < arr[j]){
            int tmp = arr[j + 1];
            arr[j + 1] = arr[j];
            arr[j] = tmp;
            j--;
        }
    }
    return arr;
}
```

![image](https://github.com/hwibaski/java-problem-solving/assets/85930725/c5d4ab80-7f63-4569-b946-27f3a5c382bd)

출처 : https://neetcode.io/courses/dsa-for-beginners/10

> 위의 서브 배열과 서브 문제와 같은 용어는 방금 배운 재귀의 개념을 떠올리게 할 수 있습니다. 그렇다면 재귀를 사용해 정렬을 수행하면 어떨까요? 그럴 수도 있지만, 재귀적으로 구현하면 반복 솔루션에 비해 이점이
> 없습니다. 실제로 재귀 솔루션은 일반적으로 더 많은 시간과 메모리를 필요로 합니다. 그리고 반복 구현이 더 직관적입니다.

## stability

정렬을 했을 때 중복된 값들의 순서가 변하지 않으면 안정(Stable) 정렬, 변하면 불안정(Unstable) 정렬인 것입니다.

[7(0번째), 3, 7(2번째)] 을 정렬해보겠습니다. 이 배열에는 두 개의 7이 있습니다.

정렬이 완료된 후에 [3, 7(0번째), 7(2번째)] 과 같이 서로 중복된 값들의 상대적인 순서가 변하지 않았으면 안정 정렬입니다.

[3, 7(2번째), 7(0번째)] 이 배열과 같이 정렬되면 불안정 정렬입니다.

## 특징

- 데이터를 비교하면서 찾기 때문에 비교 정렬이다.
- 정렬할 대상이 되는 데이터 이외에는 추가적인 공간을 필요로 하지 않기 때문에 제자리 정렬 (in-place sort)이다.
- 정렬을 하기 전에서 같은 key값을 가진 원소의 순서가 정렬 후에도 유지되는 안정 정렬이다.

## 장점

- 알고리즘이 단순하다.
- 추가적인 메모리 소비가 작다.
- 거의 정렬 된 경우 매우 효율적이고 최선의 경우 O(N)의 시간복잡도를 갖는다.
- 안정 정렬이 가능하다.

## 단점

- 비교적 많은 수들의 이동을 포함하며 비교할 수가 많고 크기가 클 경우에 적합하지 않다.
- 최악의 경우 O(N^2)의 시간복잡도를 갖는다.
- 데이터의 상태에 따라서 성능 편차가 매우 크다.

## 시간 복잡도

삽입 정렬의 base case의 경우 O(n)의 시간 복잡도를 가집니다.

위의 코드에서 보듯이 우리는 모든 요소들을 일단 순회해야하기 때문입니다.

이미 모두 정렬된 배열이라면 while문을 실행하지 않으므로 O(n)의 시간 복잡도를 가집니다.

최악의 경우에는 n개의 요소를 for문을 돌면서 모든 요소들을 while문을 반복하므로 O(n^2)입니다.

> 더 정확하게 말하자면 n^2 / 2 이다. 하지만 상수항은 무시되므로 n^2의 시간 복잡도를 가집니다.

n^2은 아래의 격자와 같이 4 * 4 격자를 다 채우는 것이라고 볼 수 있습니다.

| O | O | O | O |
|---|---|---|---|
| O | O | O | O |
| O | O | O | O |
| O | O | O | O |

삽입 정렬은 어떨까요?

서브배열의 크기가 2일 때, 즉 첫 번째 비교에서는 최대 한 번의 비교가 일어납니다.
그 다음, 서브 배열의 크기가 3일 때는 최 대 두 번의 비교가 일어납니다.
n^2 의 반만큼 연산이 수행됩니다. (대략적으로 반을 의미합니다)

| O |   |   |   |
|---|---|---|---|
| O | O |   |   |
| O | O | O |   |
| O | O | O | O |

하지만 시간 복잡도 계산에서의 상수항은 무시되므로 O(n^2)의 시간 복잡도를 가집니다.

### reference

- https://neetcode.io/courses/dsa-for-beginners/10
- https://hongcoding.tistory.com/183
- https://visualgo.net/en/sorting
